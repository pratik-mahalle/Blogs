---
title: "Getting Started with Kyverno: A Kubernetes-Native Policy Engine"
slug: getting-started-with-kyverno-a-kubernetes-native-policy-engine

---

Kubernetes is an incredibly powerful container orchestration platform, but managing security, compliance, and best practices can quickly become a headache‚Äîespecially as your cluster grows.

**What if you could automatically enforce policies, block misconfigurations, and ensure security‚Äîall using simple YAML files?**

That‚Äôs exactly what **Kyverno** does. Whether you're a **beginner exploring Kubernetes** or an **experienced engineer looking for better policy automation**, this guide will walk you through:

‚úÖ **What is Kyverno and why do we need it?**  
‚úÖ **How Kyverno works**  
‚úÖ **Basic hands-on demo (security policy enforcement)**  
‚úÖ **Advanced Kyverno use cases (real-world examples)**  
‚úÖ **Final thoughts and next steps**

Let‚Äôs dive in! üöÄ

---

## **1\. What is Kyverno?**

Kyverno (Greek for "to govern") is a Kubernetes-native policy engine designed to help administrators enforce security, governance, and best practices.

Unlike Open Policy Agent (OPA), which uses the **Rego** language, Kyverno lets you **define policies in YAML**‚Äîthe same format used for Kubernetes resources.

### **Why Do We Need Kyverno?**

üî¥ **Problem:** Kubernetes allows a lot of flexibility, but without guardrails, teams can:  
‚ùå Deploy insecure containers (e.g., running as root).  
‚ùå Use images from untrusted sources.  
‚ùå Forget resource limits, causing instability.

‚úÖ **Solution:** With Kyverno, you can automatically:  
‚úî Block **insecure configurations** (e.g., prevent root containers).  
‚úî Enforce policies for **image security, resource limits, and best practices**.  
‚úî Automate **resource generation** (e.g., auto-create NetworkPolicies).

Let‚Äôs see how Kyverno works!

---

## **2\. How Kyverno Works**

Kyverno acts as a **Kubernetes Admission Controller**, intercepting API requests before they are processed.

It works in three ways:

1Ô∏è‚É£ **Validation Policies** ‚Äì Prevent misconfigurations (e.g., block privileged containers).  
2Ô∏è‚É£ **Mutation Policies** ‚Äì Automatically modify resources (e.g., add labels, enforce security settings).  
3Ô∏è‚É£ **Generation Policies** ‚Äì Create resources when needed (e.g., auto-generate ConfigMaps or NetworkPolicies).

Now, let‚Äôs get hands-on with Kyverno.

---

## **3\. Basic Kyverno Demo: Enforcing Security Policies**

### **Step 1: Install Kyverno**

Install Kyverno using Helm:

```sh
helm repo add kyverno https://kyverno.github.io/kyverno/
helm repo update
helm install kyverno kyverno/kyverno -n kyverno --create-namespace
```

Verify installation:

```sh
kubectl get pods -n kyverno
```

You should see running Kyverno pods.

### **Step 2: Apply a Policy to Block Root Containers**

Create a policy file (`disallow-root-user.yaml`):

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-root-user
spec:
  validationFailureAction: Enforce
  rules:
  - name: validate-non-root-user
    match:
      resources:
        kinds:
        - Pod
    validate:
      message: "Running containers as root is not allowed!"
      pattern:
        spec:
          containers:
          - securityContext:
              runAsNonRoot: true
```

Apply the policy:

```sh
kubectl apply -f disallow-root-user.yaml
```

### **Step 3: Test the Policy**

Try deploying an insecure pod:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: root-pod
spec:
  containers:
  - name: test-container
    image: nginx
    securityContext:
      runAsNonRoot: false
```

Apply it:

```sh
kubectl apply -f root-pod.yaml
```

üö® **Kyverno blocks the request**:

```plaintext
Error from server: admission webhook "validate.kyverno.svc" denied the request: Running containers as root is not allowed!
```

‚úÖ **Security enforced!** Now, let‚Äôs explore more advanced use cases.

---

## **4\. Advanced Kyverno Use Cases**

Kyverno can do much more than just block bad configurations. Here are **real-world examples** of how organizations use Kyverno for security, automation, and compliance.

### üîπ **1\. Enforcing Image Signing (Supply Chain Security)**

**Problem:**  
Anyone can deploy images from **unverified registries**, leading to potential security risks.

**Solution:**  
Enforce that only **signed container images** from trusted repositories can be used.

**Kyverno Policy:**

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-signed-images
spec:
  validationFailureAction: Enforce
  rules:
  - name: check-image-signature
    match:
      resources:
        kinds:
        - Pod
    validate:
      message: "Only signed images from ghcr.io/trusted are allowed."
      pattern:
        spec:
          containers:
          - image: "ghcr.io/trusted/*"
```

‚úÖ Now, any unsigned or untrusted image will be **automatically blocked**.

---

### üîπ **2\. Auto-Generating Network Policies for New Namespaces**

**Problem:**  
Developers often forget to define **NetworkPolicies**, leaving workloads open to unwanted traffic.

**Solution:**  
Use Kyverno to **automatically generate a default NetworkPolicy** when a new namespace is created.

**Kyverno Policy:**

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: generate-network-policy
spec:
  rules:
  - name: create-default-network-policy
    match:
      resources:
        kinds:
        - Namespace
    generate:
      kind: NetworkPolicy
      apiVersion: networking.k8s.io/v1
      namespace: "{{request.object.metadata.name}}"
      name: default-deny
      data:
        spec:
          podSelector: {}
          policyTypes:
          - Ingress
          - Egress
```

‚úÖ Now, every new namespace automatically gets a **default deny-all NetworkPolicy**.

---

### üîπ **3\. Enforcing Resource Limits for Pods**

**Problem:**  
Developers often forget to set **CPU and memory limits**, leading to resource exhaustion.

**Solution:**  
Ensure all workloads define `requests` and `limits` for CPU and memory.

**Kyverno Policy:**

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: enforce-resource-limits
spec:
  validationFailureAction: Enforce
  rules:
  - name: require-resources
    match:
      resources:
        kinds:
        - Pod
    validate:
      message: "All containers must have CPU and memory limits."
      pattern:
        spec:
          containers:
          - resources:
              limits:
                memory: "?*"
                cpu: "?*"
              requests:
                memory: "?*"
                cpu: "?*"
```

‚úÖ Now, any pod without resource limits will be **denied deployment**.

---

## **5\. Final Thoughts**

Kyverno makes **policy enforcement in Kubernetes simple and powerful**.

‚úÖ **New developers** can start enforcing security with YAML-based policies.  
‚úÖ **Experienced engineers** can automate security, compliance, and governance.  
‚úÖ **Organizations** can ensure consistency and prevent misconfigurations.

### **Next Steps**

üöÄ Try Kyverno in your Kubernetes cluster.  
üìñ Explore more policies in the [Kyverno documentation](https://kyverno.io/docs/).  
üí¨ Share your experiences and use cases in the comments!

Would you like to see more Kyverno use cases? Let us know! üöÄ